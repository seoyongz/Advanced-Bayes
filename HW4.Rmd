---
title: "HW4"
author: "?????????"
date: "2023-06-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(gtools)
library(stats)
library(LaplacesDemon)
library(ggplot2)
library(MASS)
library(latex2exp)
library(mvtnorm)
```

# HW4

## Q1.(c)

Initial Setting
```{r}
n = 200
p = 1
sigma = 0.1
```

Generate x_i
```{r}
set.seed(512)
xi = runif(n, 0, 1)
mux = sin(2*pi*xi^3)^3
```

Generate y_i
```{r}
set.seed(512)
yi = rnorm(n, mux, sigma)
plot(xi, yi, cex=0.5)
```

covariance function
```{r}
cov_k = function(x1, x2, tau, l){
  mat = matrix(nrow = length(x1), ncol=length(x2))
  for(i in 1:length(x2)){
    mat[,i] = tau^2*exp(-((x1-x2[i])^2)/(l^2))
  }
  return(mat)
}
```

Pre-specify the values of $\tau$ and $l$. 
```{r}
x_tilde = seq(1:999)/1000
```

```{r}
# Draw sigma2
sigma_grid = seq(0.01, 2, length.out=n)
sigma_prob = c()
sigma_prob = dnorm(yi, mux, sigma_grid)/(sigma_grid^2)

```

```{r}
niter = 100
# tau = 0.25, l = 0.5
mu_tilde1 = matrix(nrow=niter, ncol=length(x_tilde))
tau = 0.25; l = 0.5

Kxxt = cov_k(xi, x_tilde, tau, l)
Kxtxt = cov_k(x_tilde, x_tilde, tau, l)
Kxx = cov_k(xi, xi, tau, l)

sigma_grid = seq(0.01, 2, length.out=n)
Kxx_inv = array(dim=c(n,n,niter))
for(i in 1:niter){
   Kxx_inv[,,i] = solve(Kxx + diag(rep(sigma_grid[i], n)))
}

# Sampling sigma with grid sampling
sigma_prob = c()
for(i in 1:n){
  sigma_prob[i] = exp(dmvnorm(yi, rep(0, n), Kxx + diag(n)*sigma_grid[i]^2, log=T) - 2*log(sigma_grid[i]))
}
sigma_samp_n = sample(seq(1, length(sigma_grid)), niter, replace=T ,prob=sigma_prob)
sigma_samp = sigma_grid[sigma_samp_n]

# Sampling mu_tilde
for(t in 1:niter){
  
  tmp_cov = Kxtxt - t(Kxxt) %*%Kxx_inv[,,sigma_samp_n[t]]%*%Kxxt
  tmp_mu = t(Kxxt)%*%Kxx_inv[,,sigma_samp_n[t]]%*%yi
  
  mu_tilde1[t, ] = mvrnorm(1, tmp_mu, tmp_cov)
}

```


```{r}
# tau = 0.5, l = 0.5
mu_tilde2 =  matrix(nrow=niter, ncol=length(x_tilde))
#### Draw mu tilde
tau = 0.5; l = 0.5

Kxxt = cov_k(xi, x_tilde, tau, l)
Kxtxt = cov_k(x_tilde, x_tilde, tau, l)
Kxx = cov_k(xi, xi, tau, l)

sigma_grid = seq(0.01, 2, length.out=n)
Kxx_inv = array(dim=c(n,n,niter))
for(i in 1:niter){
   Kxx_inv[,,i] = solve(Kxx + diag(rep(sigma_grid[i], n)))
}

# Sampling sigma with grid sampling
sigma_prob = c()
for(i in 1:n){
  sigma_prob[i] = exp(dmvnorm(yi, rep(0, n), Kxx + diag(n)*sigma_grid[i]^2, log=T) - 2*log(sigma_grid[i]))
}
sigma_samp_n = sample(seq(1, length(sigma_grid)), niter, replace=T ,prob=sigma_prob)
sigma_samp = sigma_grid[sigma_samp_n]

# Sampling mu_tilde
for(t in 1:niter){
  
  tmp_cov = Kxtxt - t(Kxxt) %*%Kxx_inv[,,sigma_samp_n[t]]%*%Kxxt
  tmp_mu = t(Kxxt)%*%Kxx_inv[,,sigma_samp_n[t]]%*%yi
  
  mu_tilde2[t, ] = mvrnorm(1, tmp_mu, tmp_cov)
}
```

```{r}
# tau = 0.25, l = 2
mu_tilde3 = matrix(nrow=niter, ncol=length(x_tilde))
#### Draw mu tilde
tau = 0.25; l = 2

Kxxt = cov_k(xi, x_tilde, tau, l)
Kxtxt = cov_k(x_tilde, x_tilde, tau, l)
Kxx = cov_k(xi, xi, tau, l)

sigma_grid = seq(0.01, 2, length.out=n)
Kxx_inv = array(dim=c(n,n,niter))
for(i in 1:niter){
   Kxx_inv[,,i] = solve(Kxx + diag(rep(sigma_grid[i], n)))
}

# Sampling sigma with grid sampling
sigma_prob = c()
for(i in 1:n){
  sigma_prob[i] = exp(dmvnorm(yi, rep(0, n), Kxx + diag(n)*sigma_grid[i]^2, log=T) - 2*log(sigma_grid[i]))
}
sigma_samp_n = sample(seq(1, length(sigma_grid)), niter, replace=T ,prob=sigma_prob)
sigma_samp = sigma_grid[sigma_samp_n]

# Sampling mu_tilde
for(t in 1:niter){
  
  tmp_cov = Kxtxt - t(Kxxt) %*%Kxx_inv[,,sigma_samp_n[t]]%*%Kxxt
  tmp_mu = t(Kxxt)%*%Kxx_inv[,,sigma_samp_n[t]]%*%yi
  
  mu_tilde3[t, ] = mvrnorm(1, tmp_mu, tmp_cov)
}
```

```{r}
# tau = 0.5, l = 2
mu_tilde4 = matrix(nrow=niter, ncol=length(x_tilde))
#### Draw mu tilde
tau = 0.5; l = 2

Kxxt = cov_k(xi, x_tilde, tau, l)
Kxtxt = cov_k(x_tilde, x_tilde, tau, l)
Kxx = cov_k(xi, xi, tau, l)

sigma_grid = seq(0.01, 2, length.out=n)
Kxx_inv = array(dim=c(n,n,niter))
for(i in 1:niter){
   Kxx_inv[,,i] = solve(Kxx + diag(rep(sigma_grid[i], n)))
}

# Sampling sigma with grid sampling
sigma_prob = c()
for(i in 1:n){
  sigma_prob[i] = exp(dmvnorm(yi, rep(0, n), Kxx + diag(n)*sigma_grid[i]^2, log=T) - 2*log(sigma_grid[i]))
}
sigma_samp_n = sample(seq(1, length(sigma_grid)), niter, replace=T ,prob=sigma_prob)
sigma_samp = sigma_grid[sigma_samp_n]

# Sampling mu_tilde
for(t in 1:niter){
  
  tmp_cov = Kxtxt - t(Kxxt) %*%Kxx_inv[,,sigma_samp_n[t]]%*%Kxxt
  tmp_mu = t(Kxxt)%*%Kxx_inv[,,sigma_samp_n[t]]%*%yi
  
  mu_tilde4[t, ] = mvrnorm(1, tmp_mu, tmp_cov)
}
```

### Posterior mean and credible interval
```{r}
post_mean1 = apply(mu_tilde1, 2, mean)
post_LB1 = apply(mu_tilde1, 2, quantile, 0.025)
post_UB1 = apply(mu_tilde1, 2, quantile, 0.975)

post_mean2 = apply(mu_tilde2, 2, mean)
post_LB2 = apply(mu_tilde2, 2, quantile, 0.025)
post_UB2 = apply(mu_tilde2, 2, quantile, 0.975)

post_mean3 = apply(mu_tilde3, 2, mean)
post_LB3 = apply(mu_tilde3, 2, quantile, 0.025)
post_UB3 = apply(mu_tilde3, 2, quantile, 0.975)

post_mean4 = apply(mu_tilde4, 2, mean)
post_LB4 = apply(mu_tilde4, 2, quantile, 0.025)
post_UB4 = apply(mu_tilde4, 2, quantile, 0.975)
```

#### Draw the posterior mean curve and 95% credible band on $(0,1)$
```{r}
ggplot(mapping = aes(x=x_tilde, y=post_mean1)) +
  geom_line(mapping = aes(x=xi, y=sin(2*pi*xi^3)^3), color="red", size=1.0, alpha=0.7) +
  geom_line(color="blue", size=0.5) +
  geom_ribbon(aes(ymin=post_LB1, ymax=post_UB1), alpha=0.4) +
  geom_point(mapping=aes(x=xi, y=yi), alpha=0.3, size=0.2)+
  ggtitle("", TeX('Posterior mean and the 95% credible interval when $\\tau = 0.25$, $l = 0.5$')) 

ggplot(mapping = aes(x=x_tilde, y=post_mean2)) +
  geom_line(mapping = aes(x=xi, y=sin(2*pi*xi^3)^3), color="red", size=1.0, alpha=0.7) +
  geom_line(color="blue", size=0.5) +
  geom_ribbon(aes(ymin=post_LB2, ymax=post_UB2), alpha=0.4) +
  geom_point(mapping=aes(x=xi, y=yi), alpha=0.3, size=0.2)+
  ggtitle("", TeX('Posterior mean and the 95% credible interval when $\\tau = 0.5$, $l = 0.5$')) 

ggplot(mapping = aes(x=x_tilde, y=post_mean3)) +
  geom_line(mapping = aes(x=xi, y=sin(2*pi*xi^3)^3), color="red", size=1.0, alpha=0.7) +
  geom_line(color="blue", size=0.5) +
  geom_ribbon(aes(ymin=post_LB3, ymax=post_UB3), alpha=0.4) +
  geom_point(mapping=aes(x=xi, y=yi), alpha=0.3, size=0.2)+
  ggtitle("", TeX('Posterior mean and the 95% credible interval when $\\tau = 0.25$, $l = 2$')) 

ggplot(mapping = aes(x=x_tilde, y=post_mean4)) +
  geom_line(mapping = aes(x=xi, y=sin(2*pi*xi^3)^3), color="red", size=1.0, alpha=0.7) +
  geom_line(color="blue", size=0.5) +
  geom_ribbon(aes(ymin=post_LB4, ymax=post_UB4), alpha=0.4) +
  geom_point(mapping=aes(x=xi, y=yi), alpha=0.3, size=0.2)+
  ggtitle("", TeX('Posterior mean and the 95% credible interval when $\\tau = 0.5$, $l = 2$')) 

```



## Q2.(b)
Load the data
```{r}
setwd("/Users/seoyoung/Desktop/2/고급베이즈")
galaxy = read.table("galaxy.txt", header=T)
```

```{r}
head(galaxy, 10)
summary(galaxy)
```

#### Gibbs Procedure

```{r}
y = galaxy$speed
hist(y, breaks=50, freq=F)
```
I'll use H=4 for initial value

Sampling Settings
```{r}
niter = 10000
nburn = 2000

```

Specify the values of Hyper parameters and H
```{r}
H = 4

# hyper-parameters
a = rep(1/H, H)
mu0 = mean(y)
tauh = sd(y)
a_tau = 0.001
b_tau = 0.001
kappa0 = 1
```

```{r}
# Initial value
newpi_h = rdirichlet(1, a)
newtau_h = rinvgamma(H, a_tau, b_tau)
newmu_h = rnorm(H, mu0, sqrt(kappa0)*newtau_h)
```

```{r}
mu_samp = matrix(rep(NA, niter*H), ncol=H)
pi_samp = matrix(rep(NA, niter*H), ncol=H)
tau_samp = matrix(rep(NA, niter*H), ncol=H)
zi_samp = matrix(rep(NA, niter*n), ncol=n)
kappa_samp = matrix(rep(NA, niter*H), ncol=H)
```

Sampling procedure
```{r}
n = length(y)
probs = matrix(rep(NA, n*H), ncol=H)
newzi = rep(NA, n)
nh = rep(NA, H)
ybar_h = rep(NA, H)
newb_tau = rep(NA, H)

for(i in 1:niter){
  
  # 1. Update zi from its conditional posterior
  for(h in 1:H){
    probs[, h] = newpi_h[h] * dnorm(y, newmu_h[h], newtau_h[h])
  }
  
  for(j in 1:n){
    newzi[j] = which(rmultinom(1, 1, prob=probs[j,])==1)
  }
  
  for(h in 1:H){
    nh[h] = sum(newzi == h)
    ybar_h[h] = mean(y[newzi==h])
  }
  
  # 2. Update (mu_h, tau_h) from its conditional posterior
  newkappa_h = (kappa0^(-1) + nh)^(-1)
  newa_tau = a_tau + nh/2
  for(h in 1:H){
    newb_tau[h] = b_tau + 0.5*(sum((y[newzi==h] - ybar_h[h])^2) + nh[h]/(1+kappa0*nh[h])*(ybar_h[h] - mu0)^2)
  }
  
  newtau_h = rinvgamma(H, newa_tau, newb_tau)
  newmu_h = rnorm(H, newkappa_h*(kappa0^(-1)*mu0 + nh*ybar_h), newtau_h)
  
  # 3. Update (pi_1, ..., pi_H) from its conditional posterior
  newpi = rdirichlet(1, a + nh)
  
  # Store the samples
  mu_samp[i,] = newmu_h
  pi_samp[i,] = newpi_h
  tau_samp[i,] = newtau_h
  zi_samp[i,] = newzi
  kappa_samp[i,] = newkappa_h
}
```

#### pointwise mean curve
```{r}
post_y = rep(NA, n)
for(i in 1:n){
  post_y[i] = sum(pi_samp*dnorm(y[i], mu_samp, tau_samp))
}
post_y = post_y/niter
```

```{r}
post_LB = apply(post_y, 2, quantile, 0.025)
post_UB = apply(post_y, 2, quantile, 0.975)
```


```{r}
ggplot() + 
  geom_histogram(mapping=aes(x=y, y=..density..), fill="orange", alpha=0.6) +
  geom_line(mapping=aes(x=post_y, y=..density..),stat="density", size=1.0) +
  geom_ribbon(aes(ymin=post_LB, ymax=post_UB), alpha=0.4)

```


#### 95% credible interval band
```{r}
ggplot(mapping = aes(x=x0, y=post_mean_mux)) +
  geom_line(mapping = aes(x=xi, y=sin(2*pi*xi^3)^3), color="red", size=1.0, alpha=0.8) +
  geom_line(color="blue", size=1.0, linetype="dashed") +
  geom_ribbon(aes(ymin=post_LB_mux, ymax=post_UB_mux), alpha=0.4) +
  geom_point(mapping=aes(x=xi, y=y), alpha=0.3, size=0.2)+
  ggtitle("Posterior mean and the 95% credible interval") 
```


